src/ch_helper.c:	if (v->size != 0)
src/ch_helper.c:		i = -1;
src/ch_helper.c:		while (++i < v->size)
src/ch_helper.c:	if (*str == '-')
src/ch_helper.c:		sign = -1;
src/ch_helper.c:	if (*str == '-' || *str == '+')
src/ch_helper.c:		res = res * 10 + (*str - '0');
src/ch_helper.c:		if ((res * sign) > 2147483647 || (res * sign) < -2147483648)
src/ch_main.c:	while (argv[++i] && ft_strlen(argv[i]) > 1 && argv[i][0] == '-')
src/ch_main.c:			if ((k = exist_in(argv[i][j], possible_options)) != -1)
src/ch_main.c:		if (check == -1 || ch_check_line(line) == 0)
src/ch_main.c:			return (-1);
src/ch_main.c:			if ((check = ch_handle_lines(&a, &b, &opt)) != -1)
src/ch_print.c:	fl = exist_in('a', l) != -1 ? 0 : 2;
src/ch_print.c:	fl += exist_in('b', l) != -1 ? 0 : 1;
src/ch_print.c:	fl += exist_in('s', l) != -1 ? 10 : 0;
src/ch_print.c:	fl += exist_in('p', l) != -1 ? 20 : 0;
src/ch_print.c:	fl += exist_in('r', l) != -1 ? 30 : 0;
src/ch_print.c:	si = p->size;
src/ch_print.c:	si = p->size;
src/ch_print.c:	div = (int)a->size - (int)(b->size);
src/ch_print.c:	i = a->size == 0 ? 0 : (int)(a->size);
src/ch_print.c:	j = b->size == 0 ? 0 : (int)(b->size);
src/ch_print.c:		if (div >= 0 && i--)
src/ch_print.c:		if (div <= 0 && j--)
src/ch_print.c:		div -= div > 0 ? 1 : 0;
src/ps_get.c:	if (p->size == 0)
src/ps_get.c:	while (*pile_get(p, (int)p->size - 1 - i) <= limit &&
src/ps_get.c:			*pile_get(p, (int)p->size - 1 - i) != 1)
src/ps_get.c:	if (p->size == 0)
src/ps_get.c:	i = p->size;
src/ps_get.c:	while (--i >= 0)
src/ps_get.c:	return ((int)(sum / (int)p->size + 0.5));
src/ps_get.c:	if (p->size == 0)
src/ps_get.c:	while (*pile_get(p, (int)p->size - 1 - i) <= top_value &&
src/ps_get.c:			*pile_get(p, (int)p->size - 1 - i) != 1)
src/ps_get.c:		sum += *pile_get(p, (int)p->size - 1 - i);
src/ps_get.c:	if (p->size == 0)
src/ps_get.c:	i = -1;
src/ps_get.c:	while (++i < p->size)
src/ps_get.c:	if (p->size == 0)
src/ps_get.c:	i = -1;
src/ps_get.c:	while (++i < p->size)
src/ps_helper.c:	if (i > p->size)
src/ps_helper.c:	return ((int*)(p->content + i * sizeof(int)));
src/ps_helper.c:	return ((p)->content + (p)->size * sizeof(int));
src/ps_index.c:			right--;
src/ps_index.c:			right--;
src/ps_index.c:	if (p->size == 0)
src/ps_index.c:	i = p->size;
src/ps_index.c:	while (--i > 0)
src/ps_index.c:		if (*pile_get(p, i - 1) < *pile_get(p, i))
src/ps_index.c:		ps_sort(p, left, index - 1);
src/ps_index.c:	i = (int)a->size - 1;
src/ps_index.c:		while (j < (int)b->size - 1)
src/ps_index.c:			if (*pile_get(a, i) == *pile_get(b, (int)b->size - 1 - j) &&
src/ps_index.c:					*pile_get(b, (int)b->size - 1 - j) != 0x7FFFFFFF)
src/ps_index.c:				*pile_get(b, (int)b->size - 1 - j) = 0x7FFFFFFF;
src/ps_index.c:		i--;
src/ps_init.c:	ps_split_atob(a, b, ps_get_average(a), a->size);
src/ps_init.c:	if (a->size > 4)
src/ps_init.c:	while (b->size > 0)
src/ps_main.c:	if (ps_parse_arg(&a, i, argc, argv) == -1 ||
src/ps_main.c:		ps_parse_arg(&b, i, argc, argv) == -1)
src/ps_main.c:	ps_sort(&b, 0, b.size - 1);
src/ps_operators.c:	if (p->size == 0)
src/ps_operators.c:	inter = *pile_get(p, p->size - 1);
src/ps_operators.c:	if (p->size == 0)
src/ps_operators.c:	if (sender->size == 0)
src/ps_operators.c:	inter = *pile_get(sender, sender->size - 1);
src/ps_operators.c:	if (p->size < 2)
src/ps_operators.c:	inter = *pile_get(p, p->size - 2);
src/ps_operators.c:	*pile_get(p, p->size - 2) = *pile_get(p, p->size - 1);
src/ps_operators.c:	*pile_get(p, p->size - 1) = inter;
src/ps_pile.c:	self->size += datalen;
src/ps_pile.c:	if (self->size < index || pile_reserve(self, dtlen))
src/ps_pile.c:			pile_offset(self->size - index));
src/ps_pile.c:	self->size += dtlen;
src/ps_pile.c:	if (self->max > 0)
src/ps_pile.c:		self->max = 0;
src/ps_pile.c:		self->size = 0;
src/ps_pile.c:		free(self->content);
src/ps_pile.c:	else if (self->content != 0)
src/ps_pile.c:			free(self->content);
src/ps_pile.c:	if (self->size > new_size)
src/ps_pile.c:		self->size = new_size;
src/ps_pile.c:	ft_memcpy(tmp, self->content, self->size * sizeof(int));
src/ps_pile.c:	free(self->content);
src/ps_pile.c:	self->content = tmp;
src/ps_pile.c:	self->max = new_size;
src/ps_pile.c:	ft_printf("new_size = self->max : %zu\n", new_size);
src/ps_pile.c:	const size_t	total_size = size + self->size;
src/ps_pile.c:	if (total_size > self->max)
src/ps_pile.c:		new_size = (self->max > 0 ? self->max : PILE_INITIAL_SIZE);
src/ps_pile.c:	const size_t	total_size = size + self->size;
src/ps_pile.c:	if (total_size > self->max)
src/ps_pop.c:	self->size -= (len > self->size) ? self->size : len;
src/ps_pop.c:	const size_t	n = (len > self->size - index) ? self->size - index : len;
src/ps_pop.c:	if (index > self->size)
src/ps_pop.c:			pile_offset(self->size - n - index));
src/ps_pop.c:	self->size -= n;
src/ps_rotation.c:	if (b->size == 0)
src/ps_rotation.c:	ps_split_btoa(a, b, ps_get_average(b), b->size);
src/ps_rotation.c:	while ((*pile_get(a, a->size - 1) == *pile_get(a, 0) + 1 ||
src/ps_rotation.c:				*pile_get(a, a->size - 1) == 1) && !ps_is_sorted(a))
src/ps_rotation.c:	while (*pile_get(a, a->size - 1) <= top_value &&
src/ps_rotation.c:			*pile_get(a, a->size - 1) != 1)
src/ps_rotation.c:		if (*pile_get(a, a->size - 1) == *pile_get(a, 0) + 1)
src/ps_rotation.c:	while (*pile_get(a, a->size - 1) <= top_value &&
src/ps_rotation.c:			*pile_get(a, a->size - 1) != 1)
src/ps_rotation.c:		if (*pile_get(a, a->size - 1) >= average)
src/ps_rotation.c:	i = -1;
src/ps_rotation.c:		if (*pile_get(b, b->size - 1) != ps_get_max(b))
src/ps_small.c:	if (p->size == 0)
src/ps_small.c:	i = p->size;
src/ps_small.c:	while (--i > 0)
src/ps_small.c:		if (*pile_get(p, p->size - 1 - is_a) == ps_get_min(p) &&
src/ps_small.c:				*pile_get(p, p->size - 2 + is_a) == ps_get_max(p))
src/ps_small.c:		temp = -2 * is_a + 1;
src/ps_small.c:		if (*pile_get(p, i - 1) * temp > *pile_get(p, i) * temp)
src/ps_small.c:			while (i++ < (int)p->size - 1)
src/ps_small.c:			i--;
src/ps_small.c:			if (*pile_get(p, p->size - 1 - is_a) == ps_get_min(p) &&
src/ps_small.c:					*pile_get(p, p->size - 2 + is_a) == ps_get_max(p))
src/ps_small.c:	i = -1;
src/ps_small.c:	while (++i < (int)a->size)
src/ps_small.c:	if (i <= (int)a->size / 2)
src/ps_small.c:		if (*pile_get(a, a->size - 1) < average)
src/ps_small.c:			if (*pile_get(a, 0) + 1 == *pile_get(a, a->size - 1))
src/ps_split.c:	if (ps_get_max(b) == *pile_get(b, b->size - 1))
src/ps_split.c:		if (*pile_get(b, b->size - 1) == *pile_get(a, 0) + 1 ||
src/ps_split.c:				*pile_get(b, b->size - 1) == 1)
src/ps_split.c:	while (size-- > 0)
src/ps_split.c:		if (b->size < 13)
src/ps_split.c:			if (average <= *pile_get(b, b->size - 1))
src/ps_split.c:				if (*pile_get(b, b->size - 1) == *pile_get(a, 0) + 1 ||
src/ps_split.c:						*pile_get(b, b->size - 1) == 1)
src/ps_split.c:	i = -1;
src/ps_split.c:		if (average > *pile_get(a, a->size - 1))
src/ps_split.c:	i = -1;
src/ps_split.c:	while (++i < (int)b->size)
src/ps_split.c:	if (i <= (int)b->size / 2)
src/ps_verify.c:		return (-1);
src/ps_verify.c:	ft_printf("a->content : %d (%x), int_arg: %d,  max : %d, size : %d\n", a->content, int_arg, &a->content, a->max, a->size);
src/ps_verify.c:	ft_printf("a->content : %d (%x), int_arg: %d,  max : %d, size : %d\n", a->content, int_arg, &a->content, a->max, a->size);
src/ps_verify.c:	if (ac - i == 1)
src/ps_verify.c:		if (ch_do_parse(a, i, av, only_one) == -1)
src/ps_verify.c:			return (-1);
